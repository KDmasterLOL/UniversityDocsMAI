<script>
	import { Math } from "docs-lib";
</script>

<template lang="pug">
ol
	//- li: a(href="$lib/books/Е.Л. Богданова, К.А. Соловейчик, К.Г. Аркина. НЕЛИНЕЙНОЕ ПРОГРАММИРОВАНИЕ.pdf") 
	li: a(href="http://dit.isuct.ru/IVT/sitanov/Literatura/M171.html") Методичка 211
hgroup
		h3 Унимодальные и бимодальные функции
		+source(links=['https://upread.ru/art.php?id=700', 'https://myweb.uiowa.edu/pbreheny/7110/wiki/unimodal.html'])
dl
	dt: dfn Унимодальная функция
	dd(title="one dimensional") 
		+m.block f: \real \to \real, \exists m: \begin{cases}\ddv {f(\forall x \lt m)}x \gt 0 \\ \ddv {f(\forall x \gt m)}x \lt 0 \end{cases} 
		p A function #[+m f: \real \to \real] if there exists a point #[+m m] such that #[+m f] is monotonically increasing for #[+m x \le m] and monotonically decreasing for #[+m x \ge m].
	dd(title="multiple dimensions") 
		p A function #[+m f: \real^d \to \real] if there exists a point #[+m \m] such that for all #[+m \norm{u}=1], #[+m f(m + xu)] is a monotone decreasing function of #[+m x].
	dd 
		p.note A unimodal function has exactly one strict local maximum; furthermore, this point is the global maximum.
		p A sufficient #[small but not necessary] condition for unimodality is concavity.
	dd
		p Функция #[+m f(x)] монотонно увеличивающаяся при #[+m x≤m] и монотонно уменьшающася при #[+m x≥m] для некоторого значения #[+m m] и ее максимальное значение равно #[+m \max f = f(m)], и другого локального максимума нет. 
		figure
			img(src='https://upread.ru/img/art700-1.jpg')
			figcaption: ol 
				li слева график имеет только одну максимальную точку, а остальная часть графика идет вниз оттуда
				li справа график имеет только одну минимальную точку, а остальная часть графика идет вверх оттуда
		p.note Функция имеющая глобальный максимум/минимум унимодальна.
		p: small Рассмотрим функцию #[+m f(x)] в интервале #[+m [a, b]], и мы должны определить значение #[+m x], для которого функция максимизируется. Функция строго увеличивается в интервале #[+m [a, x]] и строго уменьшается в интервале #[+m [x, b]]. Для этого мы можем использовать модифицированный двоичный поиск, чтобы определить максимум или значение этой функции. 
	dt: dfn Бимодальная функция
	dd 
		p Функция имеющая два локальных минимума/максимума. Обычно она указывает на две различные группы #[span.example в классе есть много студентов, получающих оценку A/D: в классе есть две разные группы студентов: недостаточно и чрезмерно подготовленая].
		figure
			img(src='https://upread.ru/img/art700-2.jpg')
			figcaption С бимодальной функцией выше мы не знаем, является ли экстремум локальным или глобальным, если мы не знаем весь график. С унимодальной функцией любой экстремум, который мы находим, гарантированно является глобальным экстремумом.

article: include temp
//- section
	hgroup
		h3 Численные методы решения нелинейных уравнений
		+source(links=['https://prog-cpp.ru/digital-find/'])
	dl
		dt: dfn Решить уравнение #[+m({'f(x)': 'заданная алгебраическая или трансцендентная функция'}) f(x)= 0]
		dd 
			p Найти все его корни, то есть те значения #[+m x], которые обращают уравнение в тождество. Если уравнение достаточно сложно, то задача точного определения корней является в некоторых случаях нерешаемой. Поэтому ставится задача найти такое приближенное значение корня #[+m x], которое отличается от точного значения корня #[+m x*] на величину, по модулю не превышающую указанной точности (малой положительной величины) #[+m ε], то есть #[+m │x* – x │< \varepsilon]
			p Величина #[+m ε] называется #[dfn допустимой ошибкой], которую можно задать по своему усмотрению.
		dt: dfn Этапы приближенного решения нелинейных уравнений
		dd
			ol
				li 
					p Отделение корней - нахождение интервалов из области определения функции #[+m f(x)], в каждом из которых содержится только один корень уравнения #[+m f(x)=0].
					p Отделение корней можно проводить графически и аналитически. Для того чтобы графически отделить корни уравнения, необходимо построить график функции #[+m f(x)]. Абсциссы точек его пересечения с осью Ox являются действительными корнями уравнения. 
					details.example
						summary: +m \sin x = \frac 1x 
						ol
							li Указанное уравнение можно переписать в виде #[+m \sin x - \frac 1x = 0]
							li Для графического отсечения корней достаточно построить график функции #[img(src='https://prog-cpp.ru/wp-content/uploads/find3.png')]
							li.solution Из рисунка видно, что корень уравнения лежит в промежутке #[+m x\in (6;8)].
						
					h4 Аналитическое отделение корней
					p Аналитическое отделение корней основано на следующих теоремах. Теорема 1. Если непрерывная функция #[+m f(x)] принимает на концах отрезка [a; b] значения разных знаков, т.е. #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_19-45-50.png')] то на этом отрезке содержится по крайней мере один корень уравнения. Теорема 2. Если непрерывная на отрезке [a; b] функция #[+m f(x)] принимает на концах отрезка значения разных знаков, а производная #[+m f'(x)] сохраняет знак внутри указанного отрезка, то внутри отрезка существует единственный корень уравнения #[+m f(x) = 0].
				li Уточнение корней до заданной точности.
	h4 Уточнение корней
	p Для уточнения корней может использоваться один из следующих методов:
	ul
		li Метод последовательных приближений (метод итераций)
		li Метод Ньютона (метод касательных)
		li Метод секущих (метод хорд)
		li Метод половинного деления (метод дихотомии)
	dl
		dt: dfn Метод последовательных приближений
		dt: dfn Метод итераций
		dd
			p Численный метод решения математических задач, используемый для приближённого решения алгебраических уравнений и систем. Суть метода заключается в нахождении по приближённому значению величины следующего приближения (являющегося более точным). Метод позволяет получить решение с заданной точностью в виде предела последовательности итераций. Характер сходимости и сам факт сходимости метода зависит от выбора начального приближения решения. Функциональное уравнение может быть записано в виде #[+m x=f(x)]. Функцию #[+m f(x)] называют сжимающим отображением. Последовательность чисел #[+m x], #[+m x] ,…, #[+m x] называется итерационной, если для любого номера #[+m n>0] элемент #[+m x] выражается через элемент #[+m x] по рекуррентной формуле #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_19-46-15.png')] а в качестве #[+m x] взято любое число из области задания функции #[+m f(x)]. 
			figure
				+code('cpp').
					#define _USE_MATH_DEFINES
					#include <iostream>
					#include <cmath>
					using namespace std;
					double find(double x, double eps)
					{
						double rez; int iter = 0;
						cout << "x0= " << x << " ";
						do {
							rez = x;
							x = 1 / (sin(M_PI*x / 180));
							iter++;
						} while (fabs(rez - x) > eps && iter<20000);
						cout << iter << " iterations" << endl;
						return x;
					}
					int main() 
					{
						cout << find(7, 0.00001);
						cin.get(); 
						return 0;
					}
				figcaption Реализация на C++ для рассмотренного выше примера #[+m \sin x = \frac 1x] Уравнение может быть записано в форме #[+m x=\frac 1{\sin(\frac \pi{180}x)}]
		samp Результат выполнения #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-27_22-58-10.png')]
		dt: dfn Метод касательных
		dt: dfn Метод Ньютона
		dd
			p Если известно начальное приближение #[+m x] корня уравнения #[+m f(x)=0], то последовательные приближения находят по формуле #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-00-21.png')] Графическая интерпретация метода касательных имеет вид #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-00-36.png')] Реализация на C++ Для заданного уравнения #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-00-54.png')] производная будет иметь вид #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-01-09.png')]
			p Результат выполнения #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-27_23-02-36.png')]
		dt: dfn метод хорд
		dt: dfn Метод секущих
		dd
			p Если #[+m x], #[+m x] - приближенные значения корня уравнения #[+m f(x) = 0] и выполняется условие #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_19-45-50.png')] то последующие приближения находят по формуле #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-01-44.png')] Методом хорд называют также метод, при котором один из концов отрезка закреплен, т.е. вычисление приближения корня уравнения #[+m f(x) = 0] производят по формулам: #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-01-57.png')] Геометрическая интерпретация метода хорд: #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-02-09.png')] Реализация на C++ В отличие от двух рассмотренных выше методов, метод хорд предполагает наличие двух начальных приближений, представляющих собой концы отрезка, внутри которого располагается искомый корень.
			+code('cpp').
				#define _USE_MATH_DEFINES
				#include <iostream>
				#include <cmath>
				using namespace std;
				double find(double x, double eps)
				{
					double f, df; int iter = 0;
					cout << "x0= " << x << " ";
					do {
						f = sin(M_PI*x / 180) - 1 / x;
						df = M_PI / 180 * cos(M_PI*x / 180) + 1 / (x*x);
						x = x - f / df;
						iter++;
					} while (fabs(f) > eps && iter<20000);
					cout << iter << " iterations" << endl;
					return x;
				}
				int main() 
				{
					cout << find(1, 0.00001);
					cin.get(); return 0;
				}
				p Результат выполнения #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-27_23-06-13.png')]
			dt: dfn Метод половинного деления
			dt: dfn метод дихотомии
			dd
				p Если #[+m x], #[+m x] - приближенные значения корня уравнения #[+m f(x) = 0] и выполняется условие #[+m f(x_0)f(x_1)<0] то последующие приближения находятся по формуле #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-02-36.png')] и вычисляется #[+m f(x)]. Если #[+m f(x)=0], то корень найден. В противном случае из отрезков выбирается тот, на концах которого #[+m f(x)] принимает значения разных знаков, и проделывается аналогичная операция. Процесс продолжается до получения требуемой точности. Геометрическая интерпретация метода дихотомии #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-28_20-02-48.png')] 
				figure
					+code('cpp').
						#define _USE_MATH_DEFINES
						#include <iostream>
						#include <cmath>
						using namespace std;
						double func(double x)
						{
							return (sin(M_PI*x / 180) - 1 / x);
						}
						double find(double x0, double x1, double eps)
						{
							double left = x0, right = x1, x, fl, fr, f;
							int iter = 0;
							cout << "x0= " << x0 << " x1= " << x1 << " ";
							do {
								x = (left + right) / 2;
								f = func(x);
								if (f > 0) right = x;
								else left = x;
								iter++;
							} while (fabs(f) > eps && iter<20000);
							cout << iter << " iterations" << endl;
							return x;
						}
						int main() 
						{
							cout << find(1.0, 10.0, 0.000001);
							cin.get(); return 0;
						}
					figcaption Реализация на C++ Результат выполнения #[img(src='https://prog-cpp.ru/wp-content/uploads/2016-12-27_23-09-30.png')] Для численного поиска решения также можно использовать генетические алгоритмы. Назад: #[em Алгоритмизация]
	</template>
